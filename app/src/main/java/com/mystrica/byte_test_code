//other method use for byte testing
    @RequiresApi(api = Build.VERSION_CODES.O)
    private void bitSetLed(){



        int first=0;
        int status =1 << 4;
        int first_bit=status;
        int cal_7=1<<7;
        int bit_3= status | cal_7;

        int[] bytedata={1,bit_3,first,first};

//        UInteger ia = new UInteger(144);
//        Log.i("bitconvert", "byte data data : " + ia);

        int mask = 0x000000FF; // This is often shortened to just 0xFF
//        int unsignedValue = 144 & mask; // value = 144
//
//        Log.i("bitconvert", "byte data data unsignedValue: " + unsignedValue);
//
//        byte original = (byte) unsignedValue;
//        Log.i("bitconvert", "byte data data original: " + original);



//        byte[] setired = { (0x00 & 0xFF),(byte) (0x90 & 0xFF), (0x00 & 0xFF),  (0x00 & 0xFF)};
//        byte[] setired = { (0x00 & 0xFF),(byte) (0x90 & 0xFF), (0x00 & 0xFF),  (0x00 & 0xFF)};
        byte[] byteDatasetired = { 0, (byte) 144, 0,  0};

        byte[] convertByted=hexStringToByteArray(toHex(144+""));
//        Log.i("bitconvert", "byte data data : " + convertByted);


        //        byte[] byteData = hexToBytes("6fd362e40ebcd0945bf58dc4");
        byte[] byteData = hexToBytes("01900000");
        byte[] writeData = new byte[byteData.length];

        for (int i = 0; i < byteData.length; i++) {
            writeData[i] = byteData[i];
            Log.i("bitconvert", "byte data data : " + byteData[i]);
        }


//        for (int i = 0; i < setired.length; i++) {
//            Log.i("bitconvert", "byte data data : " + setired[i]);
//
//        }



        int first_v=0;
        int value=144;

        String convrt=Integer.toBinaryString(value);
        //String convrt_0=Integer.toBinaryString(0);

      //  int foo = Integer.parseInt(convrt, 2);


       // String con_vert= String.valueOf(convrt_0+convrt+convrt_0+convrt_0);
       // Log.i("bitconvert", "binnary covert : " + convrt +"  convert after value :"+foo+ " aa =>" + con_vert);
//         byte[] a=writeInts(bytedata);
//
//        for (int i = 0; i < a.length; i++) {
//            Log.i("bitconvert", "byte data data : " + a[i]);
//
//        }
//
//        int[] read = readInts(a);
//        for(int i=0;i<read.length;i++){
//            Log.i("bitconvert","bit data : "+read[i]);
//
//        }



    }

    public static byte[] hexToBytes(String hexRepresentation) {
        int len = hexRepresentation.length();
        byte[] data = new byte[len / 2];

        for (int i = 0; i < len; i += 2) {
            data[i / 2] = (byte) ((Character.digit(hexRepresentation.charAt(i), 16) << 4)
                    + Character.digit(hexRepresentation.charAt(i + 1), 16));
        }

        return data;
    }

    public static String toHex(String arg)
    {
        try
        {
            return String.format("%01x", new BigInteger(1, arg.getBytes("UTF-8")));
        }
        catch (UnsupportedEncodingException e)
        {
            e.printStackTrace();
            return "";
        }
    }

    public static byte[] hexStringToByteArray(String s) {
        int len = s.length();
        byte[] data = new byte[len / 2];
        for (int i = 0; i < len; i += 2) {
            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4)
                    + Character.digit(s.charAt(i+1), 16));
        }
        return data;
    }
    private String convertByted(byte[] setired) {
    String  a="";

        for(int i=0;i<setired.length;i++){

            String sf1=String.format("%02X",setired[i]);
            a=a+setired[i];
        }

        return a;
    }

    // Returns '0' for '1' and '1' for '0'
    static char flip(char c)
    {
        return (c == '0') ? '1' : '0';
    }

    // Print 1's and 2's complement of binary number
    // represented by "bin"
    static void printOneAndTwosComplement(String bin)
    {
        int n = bin.length();
        int i;

        String ones = "", twos = "";
        ones = twos = "";

        // for ones complement flip every bit
        for (i = 0; i < n; i++)
        {
            ones += flip(bin.charAt(i));
        }

        // for two's complement go from right to left in
        // ones complement and if we get 1 make, we make
        // them 0 and keep going left when we get first
        // 0, make that 1 and go out of loop
        twos = ones;
        for (i = n - 1; i >= 0; i--)
        {
            if (ones.charAt(i) == '1')
            {
                twos = twos.substring(0, i) + '0' + twos.substring(i + 1);
            }
            else
            {
                twos = twos.substring(0, i) + '1' + twos.substring(i + 1);
                break;
            }
        }

        // If No break : all are 1 as in 111 or 11111;
        // in such case, add extra 1 at beginning
        if (i == -1)
        {
            twos = '1' + twos;
        }

        Log.i("bitconvert","1's complement: " + ones);
        Log.i("bitconvert","2's complement: " + twos);
    }
    private static byte [] writeInts(int [] array) {
        try {
            ByteArrayOutputStream bos = new ByteArrayOutputStream(array.length * 4);
            DataOutputStream dos = new DataOutputStream(bos);
            for (int i = 0; i < array.length; i++) {
                dos.writeInt(array[i]);
            }

            return bos.toByteArray();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private static int [] readInts(byte [] array) {
        try {
            ByteArrayInputStream bis = new ByteArrayInputStream(array);
            DataInputStream dataInputStream = new DataInputStream(bis);
            int size = array.length / 4;
            int[] res = new int[size];
            for (int i = 0; i < size; i++) {
                res[i] = dataInputStream.readInt();
            }
            return res;
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
